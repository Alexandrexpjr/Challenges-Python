# 12: The sequence of triangle numbers is generated by adding the natural numbers.
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

# Let us list the factors of the first seven triangle numbers:

#  1: 1
#  3: 1,3
#  6: 1,2,3,6
# 10: 1,2,5,10
# 15: 1,3,5,15
# 21: 1,3,7,21
# 28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.

# What is the value of the first triangle number to have over five hundred divisors?

def get_triangle_number(n):
  triangle_number = 0
  for number in range(n + 1):
    triangle_number += number
  return triangle_number

print(get_triangle_number(8)) # It's working

def first_triangle_number_with_n_divisors(n):
  current_number = 300
  current_triangle = 1
  number_of_divisors = 1
  while(number_of_divisors < n):
    # i'll start the loop reseting the number of divisors
    number_of_divisors = 1 # It's a divisor of itself, so i start the count with '1'. Also, i'll use this number / 2 to optimize, once there's no divisor between a number and its half
    current_triangle = get_triangle_number(current_number)
    if (current_triangle % 2 == 0 and current_triangle % 3 == 0 and current_triangle % 5 == 0): # Trying to optimize, without this if the program took about 1 hour to go ( and don't end )
      for number in range(1, int(current_triangle / 2)): ## In the case wich the current triangle is odd, the division will be a float number, resulting in an error
        if(current_triangle % number == 0): number_of_divisors += 1
    current_number += 1
  return current_triangle
    
print(first_triangle_number_with_n_divisors(100)) # The 500th number took to long to compile, but it worked. i'll keep it at 100th till i optimize it

# Correct
